package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"

	"gopkg.in/yaml.v2"
)

type FieldSpec struct {
	Type        string `yaml:"type"`
	Default     any    `yaml:"default"`
	Description string `yaml:"description"`
}

type ConfigTemplate struct {
	PackageName string
	StructName  string
	Fields      []Field
}

type Field struct {
	OriginalName string
	Name         string
	VarName      string
	Type         string
	Default      string
	Description  string
}

func main() {
	schemaPath := flag.String("schema", "config_schema.yaml", "Path to config schema YAML file")
	flag.Parse()

	yamlData, err := os.ReadFile(*schemaPath)
	if err != nil {
		log.Fatalf("cannot read schema file %q: %v", *schemaPath, err)
	}

	var config map[string]FieldSpec
	if err = yaml.Unmarshal(yamlData, &config); err != nil {
		log.Fatal(err)
	}

	tmplData := ConfigTemplate{
		PackageName: "config",
		StructName:  "AppConfig",
		Fields:      parseFields(config),
	}

	writeConfig(tmplData)
	writeFake(tmplData)

	fmt.Println("✅ Конфигурационный код сгенерирован в", "internal/config")
}

func parseFields(config map[string]FieldSpec) []Field {
	var fields []Field
	for name, spec := range config {
		field := Field{
			OriginalName: name,
			Name:         toCamel(name),
			VarName:      toLowerCamel(name),
			Type:         spec.Type,
			Default:      formatDefaultValue(spec.Default),
			Description:  spec.Description,
		}
		fields = append(fields, field)
	}
	return fields
}

func formatDefaultValue(val any) string {
	switch v := val.(type) {
	case string:
		return fmt.Sprintf("%q", v)
	case int, int64, float64, bool:
		return fmt.Sprintf("%v", v)
	case []any:
		var elems []string
		for _, e := range v {
			elems = append(elems, formatDefaultValue(e))
		}
		return fmt.Sprintf("[]string{%s}", strings.Join(elems, ", "))
	case map[any]any:
		var entries []string
		isStringMap := true
		isIntMap := true
		for _, val := range v {
			switch val.(type) {
			case string:
				isIntMap = false
			case int, int64:
				isStringMap = false
			default:
				isStringMap = false
				isIntMap = false
			}
		}

		switch {
		case isStringMap:
			for k, val := range v {
				entries = append(entries, fmt.Sprintf("%q: %q", k, val))
			}
			return fmt.Sprintf("map[string]string{%s}", strings.Join(entries, ", "))
		case isIntMap:
			for k, val := range v {
				entries = append(entries, fmt.Sprintf("%q: %v", k, val))
			}
			return fmt.Sprintf("map[string]int{%s}", strings.Join(entries, ", "))
		default:
			for k, val := range v {
				entries = append(entries, fmt.Sprintf("%q: %#v", k, val))
			}
			return fmt.Sprintf("map[string]any{%s}", strings.Join(entries, ", "))
		}
	default:
		return fmt.Sprintf("%#v", val)
	}
}

func toCamel(input string) string {
	parts := strings.Split(input, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

func toLowerCamel(input string) string {
	camel := toCamel(input)
	return strings.ToLower(camel[:1]) + camel[1:]
}

func writeConfig(tmplData ConfigTemplate) {
	tmpl := template.Must(template.New("config").Funcs(template.FuncMap{
		"toCamel":      toCamel,
		"toLowerCamel": toLowerCamel,
	}).Parse(configTemplate))

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, tmplData); err != nil {
		log.Fatal(err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err := os.MkdirAll("internal/config", 0755); err != nil {
		log.Fatal(err)
	}

	if err := os.WriteFile("internal/config/config.go", formatted, 0644); err != nil {
		log.Fatal(err)
	}
}

func writeFake(tmplData ConfigTemplate) {
	fakeBuf := bytes.Buffer{}
	fakeTmpl := template.Must(template.New("fake").Funcs(template.FuncMap{
		"toCamel": toCamel,
	}).Parse(fakeTemplate))

	if err := fakeTmpl.Execute(&fakeBuf, tmplData); err != nil {
		log.Fatal(err)
	}

	formattedFake, err := format.Source(fakeBuf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err := os.WriteFile("internal/config/fake.go", formattedFake, 0644); err != nil {
		log.Fatal(err)
	}
}

const configTemplate = `// Code generated by generator; DO NOT EDIT.
package {{.PackageName}}

import (
	"context"

	clientv3 "go.etcd.io/etcd/client/v3"
	konfig "github.com/olefire/realtime-config-go"
)

type AppConfig interface {
{{- range .Fields}}
	// Get{{.Name}} возвращает значение {{.OriginalName}}. {{.Description}}
	Get{{.Name}}() {{.Type}}
{{- end}}
}

type appConfig struct {
{{- range .Fields}}
	{{.VarName}} {{.Type}} ` + "`etcd:\"{{.OriginalName}}\"`" + `
{{- end}}
}

func NewAppConfig(ctx context.Context, cli *clientv3.Client, prefix string) (*konfig.RealTimeConfig, error) {
	cfg := &appConfig{
{{- range .Fields}}
		{{.VarName}}: {{.Default}},
{{- end}}
	}
	return konfig.NewRealTimeConfig(ctx, cli, prefix, cfg)
}

{{range .Fields}}
// Get{{.Name}} возвращает значение {{.OriginalName}}. {{.Description}}
func (c *appConfig) Get{{.Name}}() {{.Type}} {
	return c.{{.VarName}}
}
{{end}}
`

const fakeTemplate = `// Code generated by generator; DO NOT EDIT.
package {{.PackageName}}

type FakeAppConfig struct {
	{{- range .Fields}}
	{{.VarName}} {{.Type}}
	{{- end}}
}

{{range .Fields}}
// Get{{.Name}} возвращает значение {{.OriginalName}}. {{.Description}}
func (f *FakeAppConfig) Get{{.Name}}() {{.Type}} {
	return f.{{.VarName}}
}
{{end}}
`
